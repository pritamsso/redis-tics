name: Build and Release

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: false
        default: ''

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  prepare-version:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.bump_version.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Bump version before build
        id: bump_version
        run: |
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            CURRENT=$(grep '^version' src-tauri/Cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
            
            if git rev-parse "v${CURRENT}" >/dev/null 2>&1; then
              MAJOR=$(echo $CURRENT | cut -d. -f1)
              MINOR=$(echo $CURRENT | cut -d. -f2)
              PATCH=$(echo $CURRENT | cut -d. -f3)
              NEW_PATCH=$((PATCH + 1))
              VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
              echo "Auto-incrementing version from $CURRENT to $VERSION"
              
              sed -i "s/^version = \"$CURRENT\"/version = \"$VERSION\"/" src-tauri/Cargo.toml
              sed -i "s/\"version\": \"$CURRENT\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json
              sed -i "s/\"version\": \"$CURRENT\"/\"version\": \"$VERSION\"/" package.json
              
              git config --local user.email "github-actions[bot]@users.noreply.github.com"
              git config --local user.name "github-actions[bot]"
              git add src-tauri/Cargo.toml src-tauri/tauri.conf.json package.json
              git commit -m "chore: bump version to $VERSION [skip ci]"
              git push origin main
            else
              VERSION=$CURRENT
            fi
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

  build:
    needs: prepare-version
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            target: 'aarch64-apple-darwin'
            name: 'macOS-ARM64'
            rust_target: 'aarch64-apple-darwin'
            bundle_path: 'src-tauri/target/aarch64-apple-darwin/release/bundle'
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
            target: 'x86_64-apple-darwin'
            name: 'macOS-Intel'
            rust_target: 'x86_64-apple-darwin'
            bundle_path: 'src-tauri/target/x86_64-apple-darwin/release/bundle'
          - platform: 'ubuntu-22.04'
            args: ''
            target: ''
            name: 'Linux'
            rust_target: ''
            bundle_path: 'src-tauri/target/release/bundle'
          - platform: 'windows-latest'
            args: ''
            target: ''
            name: 'Windows'
            rust_target: ''
            bundle_path: 'src-tauri/target/release/bundle'

    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Install dependencies (Ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable

      - name: Add Rust target
        if: matrix.rust_target != ''
        run: rustup target add ${{ matrix.rust_target }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install frontend dependencies
        run: npm ci

      - name: Build Tauri app
        run: npm run tauri build -- ${{ matrix.args }}

      - name: Ad-hoc sign macOS app
        if: matrix.platform == 'macos-latest'
        run: |
          # Find and ad-hoc sign the app bundle to reduce Gatekeeper issues
          APP_PATH=$(find ${{ matrix.bundle_path }} -name "*.app" -type d | head -1)
          if [ -n "$APP_PATH" ]; then
            echo "Ad-hoc signing: $APP_PATH"
            codesign --force --deep --sign - "$APP_PATH" || echo "Ad-hoc signing skipped"
          fi

      - name: List built files (debug)
        shell: bash
        run: |
          echo "=== Bundle directory contents ==="
          find ${{ matrix.bundle_path }} -type f 2>/dev/null || echo "Bundle path not found"

      - name: Upload macOS DMG
        if: matrix.platform == 'macos-latest'
        uses: actions/upload-artifact@v4
        with:
          name: redis-tics-${{ matrix.name }}-dmg
          path: ${{ matrix.bundle_path }}/dmg/*.dmg
          if-no-files-found: warn

      - name: Upload Linux DEB
        if: matrix.platform == 'ubuntu-22.04'
        uses: actions/upload-artifact@v4
        with:
          name: redis-tics-${{ matrix.name }}-deb
          path: ${{ matrix.bundle_path }}/deb/*.deb
          if-no-files-found: warn

      - name: Upload Linux AppImage
        if: matrix.platform == 'ubuntu-22.04'
        uses: actions/upload-artifact@v4
        with:
          name: redis-tics-${{ matrix.name }}-appimage
          path: ${{ matrix.bundle_path }}/appimage/*.AppImage
          if-no-files-found: warn

      - name: Upload Windows MSI
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: redis-tics-${{ matrix.name }}-msi
          path: ${{ matrix.bundle_path }}/msi/*.msi
          if-no-files-found: warn

      - name: Upload Windows NSIS
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: redis-tics-${{ matrix.name }}-nsis
          path: ${{ matrix.bundle_path }}/nsis/*.exe
          if-no-files-found: warn

  release:
    needs: [prepare-version, build]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set version from prepare job
        id: get_version
        run: |
          VERSION="${{ needs.prepare-version.outputs.version }}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Using version: $VERSION"

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: List downloaded artifacts
        run: |
          echo "=== All downloaded artifacts ==="
          find artifacts -type f

      - name: Prepare release files
        run: |
          mkdir -p release-files
          
          # Copy and rename files for clarity
          find artifacts -name "*.dmg" -exec cp {} release-files/ \;
          find artifacts -name "*.dmg.sig" -exec cp {} release-files/ \;
          find artifacts -name "*.deb" -exec cp {} release-files/ \;
          find artifacts -name "*.deb.sig" -exec cp {} release-files/ \;
          find artifacts -name "*.AppImage" -exec cp {} release-files/ \;
          find artifacts -name "*.AppImage.sig" -exec cp {} release-files/ \;
          find artifacts -name "*.msi" -exec cp {} release-files/ \;
          find artifacts -name "*.msi.sig" -exec cp {} release-files/ \;
          find artifacts -name "*.exe" -exec cp {} release-files/ \;
          find artifacts -name "*.exe.sig" -exec cp {} release-files/ \;

          # Normalize names (avoid spaces to prevent URL issues)
          for f in release-files/Redis\ Tics_*; do
            [ -e "$f" ] || continue
            mv "$f" "${f//Redis Tics/Redis.Tics}"
          done

          echo "=== Files to release ==="
          ls -la release-files/

      - name: Generate Tauri updater manifest (latest.json)
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          NOTES="Redis Tics v${VERSION} - See release notes for details"

          SIG_MAC_ARM=""
          SIG_MAC_X64=""
          SIG_LINUX_APPIMAGE=""
          SIG_WINDOWS_MSI=""

          [ -f "release-files/Redis.Tics_${VERSION}_aarch64.dmg.sig" ] && SIG_MAC_ARM=$(cat "release-files/Redis.Tics_${VERSION}_aarch64.dmg.sig")
          [ -f "release-files/Redis.Tics_${VERSION}_x64.dmg.sig" ] && SIG_MAC_X64=$(cat "release-files/Redis.Tics_${VERSION}_x64.dmg.sig")
          [ -f "release-files/Redis.Tics_${VERSION}_amd64.AppImage.sig" ] && SIG_LINUX_APPIMAGE=$(cat "release-files/Redis.Tics_${VERSION}_amd64.AppImage.sig")
          [ -f "release-files/Redis.Tics_${VERSION}_x64-setup.msi.sig" ] && SIG_WINDOWS_MSI=$(cat "release-files/Redis.Tics_${VERSION}_x64-setup.msi.sig")
          
          cat > release-files/latest.json << EOF
          {
            "version": "${VERSION}",
            "notes": "${NOTES}",
            "pub_date": "${DATE}",
            "platforms": {
              "darwin-aarch64": {
                "signature": "${SIG_MAC_ARM}",
                "url": "https://github.com/pritamsso/redis-tics/releases/download/v${VERSION}/Redis.Tics_${VERSION}_aarch64.dmg"
              },
              "darwin-x86_64": {
                "signature": "${SIG_MAC_X64}",
                "url": "https://github.com/pritamsso/redis-tics/releases/download/v${VERSION}/Redis.Tics_${VERSION}_x64.dmg"
              },
              "linux-x86_64": {
                "signature": "${SIG_LINUX_APPIMAGE}",
                "url": "https://github.com/pritamsso/redis-tics/releases/download/v${VERSION}/Redis.Tics_${VERSION}_amd64.AppImage"
              },
              "windows-x86_64": {
                "signature": "${SIG_WINDOWS_MSI}",
                "url": "https://github.com/pritamsso/redis-tics/releases/download/v${VERSION}/Redis.Tics_${VERSION}_x64-setup.msi"
              }
            }
          }
          EOF
          
          echo "Generated latest.json for auto-updater"

      - name: Generate changelog
        id: changelog
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          echo "## What's Changed" > RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          
          if [ -n "$LAST_TAG" ]; then
            git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges >> RELEASE_NOTES.md
          else
            echo "- Initial release ğŸ‰" >> RELEASE_NOTES.md
          fi
          
          echo "" >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          echo "## Downloads" >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          echo "| Platform | Architecture | File |" >> RELEASE_NOTES.md
          echo "|----------|--------------|------|" >> RELEASE_NOTES.md
          echo "| macOS | Apple Silicon (M1/M2/M3) | \`Redis Tics_*.dmg\` (aarch64) |" >> RELEASE_NOTES.md
          echo "| macOS | Intel | \`Redis Tics_*.dmg\` (x86_64) |" >> RELEASE_NOTES.md
          echo "| Windows | x64 | \`.msi\` or \`.exe\` |" >> RELEASE_NOTES.md
          echo "| Linux | x64 | \`.deb\` or \`.AppImage\` |" >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          echo "### ğŸ”„ Auto-Update" >> RELEASE_NOTES.md
          echo "This version supports automatic updates. You'll be notified when new versions are available." >> RELEASE_NOTES.md
          echo "" >> RELEASE_NOTES.md
          echo "---" >> RELEASE_NOTES.md
          echo "Made with â¤ï¸ by [@pritamsso](https://github.com/pritamsso)" >> RELEASE_NOTES.md
          
          cat RELEASE_NOTES.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.get_version.outputs.version }}
          name: Redis Tics v${{ steps.get_version.outputs.version }}
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: false
          files: release-files/*
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update releases.json for website
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          DATE=$(date +%Y-%m-%d)
          
          echo "ğŸ”„ Updating releases.json for version ${VERSION}"
          
          # Get commit messages for changes
          LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            echo "ğŸ“ Getting changes since ${LAST_TAG}"
            CHANGES=$(git log ${LAST_TAG}..HEAD --pretty=format:'"%s"' --no-merges | grep -v "chore: update releases.json" | head -15 | tr '\n' ',' | sed 's/,$//')
            # Fallback if no changes found
            if [ -z "$CHANGES" ]; then
              CHANGES='"Performance improvements and bug fixes"'
            fi
          else
            CHANGES='"Initial release with multi-server management","Real-time command monitoring","Memory analytics with MEMORY STATS","Command statistics and slow log analysis","Redis Cluster support","Persistence status monitoring","Cross-platform support (macOS, Windows, Linux)"'
          fi
          
          # Create new release entry
          cat > /tmp/new_release.json << EOF
          {
            "version": "${VERSION}",
            "date": "${DATE}",
            "title": "Redis Tics v${VERSION}",
            "description": "New release of Redis Tics with improvements and fixes",
            "changes": [${CHANGES}],
            "downloads": {
              "macos_arm": "https://github.com/pritamsso/redis-tics/releases/download/v${VERSION}/Redis.Tics_${VERSION}_aarch64.dmg",
              "macos_intel": "https://github.com/pritamsso/redis-tics/releases/download/v${VERSION}/Redis.Tics_${VERSION}_x64.dmg",
              "windows_msi": "https://github.com/pritamsso/redis-tics/releases/download/v${VERSION}/Redis.Tics_${VERSION}_x64-setup.msi",
              "windows_exe": "https://github.com/pritamsso/redis-tics/releases/download/v${VERSION}/Redis.Tics_${VERSION}_x64-setup.exe",
              "linux_deb": "https://github.com/pritamsso/redis-tics/releases/download/v${VERSION}/redis-tics_${VERSION}_amd64.deb",
              "linux_appimage": "https://github.com/pritamsso/redis-tics/releases/download/v${VERSION}/Redis.Tics_${VERSION}_amd64.AppImage"
            }
          }
          EOF
          
          echo "ğŸ“¦ New release entry:"
          cat /tmp/new_release.json | jq .
          
          # Update releases.json - remove duplicate if version already exists
          if [ -f docs/releases.json ]; then
            echo "ğŸ“„ Updating existing releases.json"
            # Remove any existing entry for this version, then add new one
            jq --argjson new "$(cat /tmp/new_release.json)" \
               '.latest = $new.version | .releases = ([$new] + (.releases | map(select(.version != $new.version))))' \
               docs/releases.json > /tmp/releases_updated.json
            mv /tmp/releases_updated.json docs/releases.json
          else
            echo "ğŸ“„ Creating new releases.json"
            jq -n --argjson new "$(cat /tmp/new_release.json)" \
               '{latest: $new.version, releases: [$new]}' > docs/releases.json
          fi
          
          echo "âœ… Updated releases.json:"
          cat docs/releases.json | jq '.releases | map({version, date}) | .[:3]'

      - name: Commit and push releases.json
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Check if there are changes to commit
          git add docs/releases.json
          if git diff --staged --quiet; then
            echo "â„¹ï¸ No changes to releases.json"
            exit 0
          fi
          
          # Reset any other unstaged changes to ensure clean state
          echo "ğŸ§¹ Ensuring clean git state..."
          git diff --name-only | grep -v "docs/releases.json" | xargs -r git checkout --
          git status --short
          
          # Commit changes
          git commit -m "chore: update releases.json for v${{ steps.get_version.outputs.version }} [skip ci]"
          
          # Fetch and rebase to handle any remote changes
          echo "ğŸ“¥ Fetching latest changes from remote..."
          git fetch origin main
          
          echo "ğŸ”„ Rebasing on origin/main..."
          git rebase origin/main || {
            echo "âš ï¸ Rebase conflict detected, attempting to resolve..."
            # Check if conflict is in releases.json
            if git diff --name-only --diff-filter=U | grep -q "docs/releases.json"; then
              echo "ğŸ“ Accepting our version of releases.json..."
              git checkout --ours docs/releases.json
              git add docs/releases.json
              git rebase --continue || {
                echo "âŒ Failed to resolve conflicts"
                git rebase --abort
                exit 1
              }
            else
              echo "âŒ Unexpected conflict in other files"
              git rebase --abort
              exit 1
            fi
          }
          
          # Push changes
          echo "ğŸ“¤ Pushing changes..."
          git push origin main
          echo "âœ… Updated releases.json and pushed to repository"
